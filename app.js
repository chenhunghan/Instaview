// Generated by CoffeeScript 1.6.3
(function() {
  var AppCtrl, FlowChartController, debug, hasClassSVG, ngapp, removeClassSVG;

  if (typeof debug !== "undefined") {
    throw new Error("debug object already defined!");
  }

  debug = {};

  debug.assertObjectValid = function(obj) {
    if (!obj) {
      throw new Exception("Invalid object!");
    }
    if ($.isPlainObject(obj)) {
      throw new Error("Input is not an object! It is a " + typeof obj);
    }
  };

  ngapp = angular.module("app", ["flowChart", "hmTouchEvents"]);

  ngapp.service("flowchartModel", function() {
    var computeConnectionTangentOffset, createConnectorsViewModel, createNodesViewModel, flowchart;
    flowchart = this;
    flowchart.nodeWidth = 250;
    flowchart.nodeNameHeight = 40;
    flowchart.connectorHeight = 35;
    flowchart.computeConnectorY = function(connectorIndex) {
      return flowchart.nodeNameHeight + (connectorIndex * flowchart.connectorHeight);
    };
    flowchart.computeConnectorPos = function(node, connectorIndex, inputConnector) {
      return {
        x: node.x() + (inputConnector ? 0 : flowchart.nodeWidth),
        y: node.y() + flowchart.computeConnectorY(connectorIndex)
      };
    };
    flowchart.ConnectorViewModel = function(connectorDataModel, x, y, parentNode) {
      this.data = connectorDataModel;
      this._parentNode = parentNode;
      this._x = x;
      this._y = y;
      this.name = function() {
        return this.data.name;
      };
      this.x = function() {
        return this._x;
      };
      this.y = function() {
        return this._y;
      };
      this.parentNode = function() {
        return this._parentNode;
      };
    };
    createConnectorsViewModel = function(connectorDataModels, x, parentNode) {
      var connectorViewModel, i, viewModels;
      viewModels = [];
      if (connectorDataModels) {
        i = 0;
        while (i < connectorDataModels.length) {
          connectorViewModel = new flowchart.ConnectorViewModel(connectorDataModels[i], x, flowchart.computeConnectorY(i), parentNode);
          viewModels.push(connectorViewModel);
          ++i;
        }
      }
      return viewModels;
    };
    flowchart.NodeViewModel = function(nodeDataModel) {
      this.data = nodeDataModel;
      this.inputConnectors = createConnectorsViewModel(this.data.inputConnectors, 0, this);
      this.outputConnectors = createConnectorsViewModel(this.data.outputConnectors, flowchart.nodeWidth, this);
      this._selected = false;
      this.name = function() {
        return this.data.name || "";
      };
      this.x = function() {
        return this.data.x;
      };
      this.y = function() {
        return this.data.y;
      };
      this.width = function() {
        return flowchart.nodeWidth;
      };
      this.height = function() {
        var numConnectors;
        numConnectors = Math.max(this.inputConnectors.length, this.outputConnectors.length);
        return flowchart.computeConnectorY(numConnectors);
      };
      this.select = function() {
        this._selected = true;
      };
      this.deselect = function() {
        this._selected = false;
      };
      this.toggleSelected = function() {
        this._selected = !this._selected;
      };
      this.selected = function() {
        return this._selected;
      };
      this._addConnector = function(connectorDataModel, x, connectorsDataModel, connectorsViewModel) {
        var connectorViewModel;
        connectorViewModel = new flowchart.ConnectorViewModel(connectorDataModel, x, flowchart.computeConnectorY(connectorsViewModel.length), this);
        connectorsDataModel.push(connectorDataModel);
        connectorsViewModel.push(connectorViewModel);
      };
      this.addInputConnector = function(connectorDataModel) {
        if (!this.data.inputConnectors) {
          this.data.inputConnectors = [];
        }
        this._addConnector(connectorDataModel, 0, this.data.inputConnectors, this.inputConnectors);
      };
      this.addOutputConnector = function(connectorDataModel) {
        if (!this.data.outputConnectors) {
          this.data.outputConnectors = [];
        }
        this._addConnector(connectorDataModel, flowchart.nodeWidth, this.data.outputConnectors, this.outputConnectors);
      };
    };
    createNodesViewModel = function(nodesDataModel) {
      var i, nodesViewModel;
      nodesViewModel = [];
      if (nodesDataModel) {
        i = 0;
        while (i < nodesDataModel.length) {
          nodesViewModel.push(new flowchart.NodeViewModel(nodesDataModel[i]));
          ++i;
        }
      }
      return nodesViewModel;
    };
    flowchart.ConnectionViewModel = function(connectionDataModel, sourceConnector, destConnector) {
      this.data = connectionDataModel;
      this.source = sourceConnector;
      this.dest = destConnector;
      this._selected = false;
      this.sourceCoordX = function() {
        return this.source.parentNode().x() + this.source.x();
      };
      this.sourceCoordY = function() {
        return this.source.parentNode().y() + this.source.y();
      };
      this.sourceCoord = function() {
        return {
          x: this.sourceCoordX(),
          y: this.sourceCoordY()
        };
      };
      this.sourceTangentX = function() {
        return flowchart.computeConnectionSourceTangentX(this.sourceCoord(), this.destCoord());
      };
      this.sourceTangentY = function() {
        return flowchart.computeConnectionSourceTangentY(this.sourceCoord(), this.destCoord());
      };
      this.destCoordX = function() {
        return this.dest.parentNode().x() + this.dest.x();
      };
      this.destCoordY = function() {
        return this.dest.parentNode().y() + this.dest.y();
      };
      this.destCoord = function() {
        return {
          x: this.destCoordX(),
          y: this.destCoordY()
        };
      };
      this.destTangentX = function() {
        return flowchart.computeConnectionDestTangentX(this.sourceCoord(), this.destCoord());
      };
      this.destTangentY = function() {
        return flowchart.computeConnectionDestTangentY(this.sourceCoord(), this.destCoord());
      };
      this.select = function() {
        this._selected = true;
      };
      this.deselect = function() {
        this._selected = false;
      };
      this.toggleSelected = function() {
        this._selected = !this._selected;
      };
      this.selected = function() {
        return this._selected;
      };
    };
    computeConnectionTangentOffset = function(pt1, pt2) {
      return (pt2.x - pt1.x) / 2;
    };
    flowchart.computeConnectionSourceTangentX = function(pt1, pt2) {
      return pt1.x + computeConnectionTangentOffset(pt1, pt2);
    };
    flowchart.computeConnectionSourceTangentY = function(pt1, pt2) {
      return pt1.y;
    };
    flowchart.computeConnectionSourceTangent = function(pt1, pt2) {
      return {
        x: flowchart.computeConnectionSourceTangentX(pt1, pt2),
        y: flowchart.computeConnectionSourceTangentY(pt1, pt2)
      };
    };
    flowchart.computeConnectionDestTangentX = function(pt1, pt2) {
      return pt2.x - computeConnectionTangentOffset(pt1, pt2);
    };
    flowchart.computeConnectionDestTangentY = function(pt1, pt2) {
      return pt2.y;
    };
    flowchart.computeConnectionDestTangent = function(pt1, pt2) {
      return {
        x: flowchart.computeConnectionDestTangentX(pt1, pt2),
        y: flowchart.computeConnectionDestTangentY(pt1, pt2)
      };
    };
    flowchart.ChartViewModel = function(chartDataModel) {
      this.findNode = function(nodeID) {
        var i, node;
        i = 0;
        while (i < this.nodes.length) {
          node = this.nodes[i];
          if (node.data.id === nodeID) {
            return node;
          }
          ++i;
        }
        throw new Error("Failed to find node " + nodeID);
      };
      this.findInputConnector = function(nodeID, connectorIndex) {
        var node;
        node = this.findNode(nodeID);
        if (!node.inputConnectors || node.inputConnectors.length <= connectorIndex) {
          throw new Error("Node " + nodeID + " has invalid input connectors.");
        }
        return node.inputConnectors[connectorIndex];
      };
      this.findOutputConnector = function(nodeID, connectorIndex) {
        var node;
        node = this.findNode(nodeID);
        if (!node.outputConnectors || node.outputConnectors.length <= connectorIndex) {
          throw new Error("Node " + nodeID + " has invalid output connectors.");
        }
        return node.outputConnectors[connectorIndex];
      };
      this._createConnectionViewModel = function(connectionDataModel) {
        var destConnector, sourceConnector;
        sourceConnector = this.findOutputConnector(connectionDataModel.source.nodeID, connectionDataModel.source.connectorIndex);
        destConnector = this.findInputConnector(connectionDataModel.dest.nodeID, connectionDataModel.dest.connectorIndex);
        return new flowchart.ConnectionViewModel(connectionDataModel, sourceConnector, destConnector);
      };
      this._createConnectionsViewModel = function(connectionsDataModel) {
        var connectionsViewModel, i;
        connectionsViewModel = [];
        if (connectionsDataModel) {
          i = 0;
          while (i < connectionsDataModel.length) {
            connectionsViewModel.push(this._createConnectionViewModel(connectionsDataModel[i]));
            ++i;
          }
        }
        return connectionsViewModel;
      };
      this.data = chartDataModel;
      this.nodes = createNodesViewModel(this.data.nodes);
      this.connections = this._createConnectionsViewModel(this.data.connections);
      this.createNewConnection = function(sourceConnector, destConnector) {
        var connectionDataModel, connectionViewModel, connectionsDataModel, connectionsViewModel, destConnectorIndex, destNode, sourceConnectorIndex, sourceNode;
        debug.assertObjectValid(sourceConnector);
        debug.assertObjectValid(destConnector);
        connectionsDataModel = this.data.connections;
        if (!connectionsDataModel) {
          connectionsDataModel = this.data.connections = [];
        }
        connectionsViewModel = this.connections;
        if (!connectionsViewModel) {
          connectionsViewModel = this.connections = [];
        }
        sourceNode = sourceConnector.parentNode();
        sourceConnectorIndex = sourceNode.outputConnectors.indexOf(sourceConnector);
        if (sourceConnectorIndex === -1) {
          sourceConnectorIndex = sourceNode.inputConnectors.indexOf(sourceConnector);
          if (sourceConnectorIndex === -1) {
            throw new Error("Failed to find source connector within either inputConnectors or outputConnectors of source node.");
          }
        }
        destNode = destConnector.parentNode();
        destConnectorIndex = destNode.inputConnectors.indexOf(destConnector);
        if (destConnectorIndex === -1) {
          destConnectorIndex = destNode.outputConnectors.indexOf(destConnector);
          if (destConnectorIndex === -1) {
            throw new Error("Failed to find dest connector within inputConnectors or ouputConnectors of dest node.");
          }
        }
        connectionDataModel = {
          source: {
            nodeID: sourceNode.data.id,
            connectorIndex: sourceConnectorIndex
          },
          dest: {
            nodeID: destNode.data.id,
            connectorIndex: destConnectorIndex
          }
        };
        connectionsDataModel.push(connectionDataModel);
        connectionViewModel = new flowchart.ConnectionViewModel(connectionDataModel, sourceConnector, destConnector);
        connectionsViewModel.push(connectionViewModel);
      };
      this.addNode = function(nodeDataModel) {
        if (!this.data.nodes) {
          this.data.nodes = [];
        }
        this.data.nodes.push(nodeDataModel);
        this.nodes.push(new flowchart.NodeViewModel(nodeDataModel));
      };
      this.selectAll = function() {
        var connection, connections, i, node, nodes;
        nodes = this.nodes;
        i = 0;
        while (i < nodes.length) {
          node = nodes[i];
          node.select();
          ++i;
        }
        connections = this.connections;
        i = 0;
        while (i < connections.length) {
          connection = connections[i];
          connection.select();
          ++i;
        }
      };
      this.deselectAll = function() {
        var connection, connections, i, node, nodes;
        nodes = this.nodes;
        i = 0;
        while (i < nodes.length) {
          node = nodes[i];
          node.deselect();
          ++i;
        }
        connections = this.connections;
        i = 0;
        while (i < connections.length) {
          connection = connections[i];
          connection.deselect();
          ++i;
        }
      };
      this.updateSelectedNodesLocation = function(deltaX, deltaY) {
        var i, node, selectedNodes;
        selectedNodes = this.getSelectedNodes();
        i = 0;
        while (i < selectedNodes.length) {
          node = selectedNodes[i];
          node.data.x += deltaX;
          node.data.y += deltaY;
          ++i;
        }
      };
      this.handleNodeClicked = function(node, ctrlKey) {
        var nodeIndex;
        if (ctrlKey) {
          node.toggleSelected();
        } else {
          this.deselectAll();
          node.select();
        }
        nodeIndex = this.nodes.indexOf(node);
        if (nodeIndex === -1) {
          throw new Error("Failed to find node in view model!");
        }
        this.nodes.splice(nodeIndex, 1);
        this.nodes.push(node);
      };
      this.handleConnectionMouseDown = function(connection, ctrlKey) {
        if (ctrlKey) {
          connection.toggleSelected();
        } else {
          this.deselectAll();
          connection.select();
        }
      };
      this.deleteSelected = function() {
        var connection, connectionIndex, deletedNodeIds, newConnectionDataModels, newConnectionViewModels, newNodeDataModels, newNodeViewModels, node, nodeIndex;
        newNodeViewModels = [];
        newNodeDataModels = [];
        deletedNodeIds = [];
        nodeIndex = 0;
        while (nodeIndex < this.nodes.length) {
          node = this.nodes[nodeIndex];
          if (!node.selected()) {
            newNodeViewModels.push(node);
            newNodeDataModels.push(node.data);
          } else {
            deletedNodeIds.push(node.data.id);
          }
          ++nodeIndex;
        }
        newConnectionViewModels = [];
        newConnectionDataModels = [];
        connectionIndex = 0;
        while (connectionIndex < this.connections.length) {
          connection = this.connections[connectionIndex];
          if (!connection.selected() && deletedNodeIds.indexOf(connection.data.source.nodeID) === -1 && deletedNodeIds.indexOf(connection.data.dest.nodeID) === -1) {
            newConnectionViewModels.push(connection);
            newConnectionDataModels.push(connection.data);
          }
          ++connectionIndex;
        }
        this.nodes = newNodeViewModels;
        this.data.nodes = newNodeDataModels;
        this.connections = newConnectionViewModels;
        this.data.connections = newConnectionDataModels;
      };
      this.applySelectionRect = function(selectionRect) {
        var connection, i, node;
        this.deselectAll();
        i = 0;
        while (i < this.nodes.length) {
          node = this.nodes[i];
          if (node.x() >= selectionRect.x && node.y() >= selectionRect.y && node.x() + node.width() <= selectionRect.x + selectionRect.width && node.y() + node.height() <= selectionRect.y + selectionRect.height) {
            node.select();
          }
          ++i;
        }
        i = 0;
        while (i < this.connections.length) {
          connection = this.connections[i];
          if (connection.source.parentNode().selected() && connection.dest.parentNode().selected()) {
            connection.select();
          }
          ++i;
        }
      };
      this.getSelectedNodes = function() {
        var i, node, selectedNodes;
        selectedNodes = [];
        i = 0;
        while (i < this.nodes.length) {
          node = this.nodes[i];
          if (node.selected()) {
            selectedNodes.push(node);
          }
          ++i;
        }
        return selectedNodes;
      };
      this.getSelectedConnections = function() {
        var connection, i, selectedConnections;
        selectedConnections = [];
        i = 0;
        while (i < this.connections.length) {
          connection = this.connections[i];
          if (connection.selected()) {
            selectedConnections.push(connection);
          }
          ++i;
        }
        return selectedConnections;
      };
    };
  });

  ngapp.factory("prompt", function() {
    return prompt;
  });

  ngapp.controller("AppCtrl", [
    "$scope", "prompt", "flowchartModel", AppCtrl = function($scope, prompt, flowchartModel) {
      var aKeyCode, chartDataModel, ctrlDown, ctrlKeyCode, deleteKeyCode, escKeyCode, nextNodeID;
      deleteKeyCode = 46;
      ctrlKeyCode = 65;
      ctrlDown = false;
      aKeyCode = 17;
      escKeyCode = 27;
      nextNodeID = 10;
      chartDataModel = {
        nodes: [
          {
            name: "Example Node 1",
            id: 0,
            x: 0,
            y: 0,
            inputConnectors: [
              {
                name: "A"
              }, {
                name: "B"
              }, {
                name: "C"
              }
            ],
            outputConnectors: [
              {
                name: "A"
              }, {
                name: "B"
              }, {
                name: "C"
              }
            ]
          }, {
            name: "Example Node 2",
            id: 1,
            x: 400,
            y: 200,
            inputConnectors: [
              {
                name: "A"
              }, {
                name: "B"
              }, {
                name: "C"
              }
            ],
            outputConnectors: [
              {
                name: "A"
              }, {
                name: "B"
              }, {
                name: "C"
              }
            ]
          }
        ],
        connections: [
          {
            source: {
              nodeID: 0,
              connectorIndex: 1
            },
            dest: {
              nodeID: 1,
              connectorIndex: 2
            }
          }
        ]
      };
      $scope.keyDown = function(evt) {
        if (evt.keyCode === ctrlKeyCode) {
          ctrlDown = true;
          evt.stopPropagation();
          evt.preventDefault();
        }
      };
      $scope.keyUp = function(evt) {
        if (evt.keyCode === deleteKeyCode) {
          $scope.chartViewModel.deleteSelected();
        }
        if (evt.keyCode === aKeyCode && ctrlDown) {
          $scope.chartViewModel.selectAll();
        }
        if (evt.keyCode === escKeyCode) {
          $scope.chartViewModel.deselectAll();
        }
        if (evt.keyCode === ctrlKeyCode) {
          ctrlDown = false;
          evt.stopPropagation();
          evt.preventDefault();
        }
      };
      $scope.addNewNode = function() {
        var newNodeDataModel, nodeName;
        nodeName = prompt("Enter a node name:", "New node");
        if (!nodeName) {
          return;
        }
        newNodeDataModel = {
          name: nodeName,
          id: nextNodeID++,
          x: 0,
          y: 0,
          inputConnectors: [
            {
              name: "X"
            }, {
              name: "Y"
            }, {
              name: "Z"
            }
          ],
          outputConnectors: [
            {
              name: "1"
            }, {
              name: "2"
            }, {
              name: "3"
            }
          ]
        };
        $scope.chartViewModel.addNode(newNodeDataModel);
      };
      $scope.addNewInputConnector = function() {
        var connectorName, i, node, selectedNodes;
        connectorName = prompt("Enter a connector name:", "New connector");
        if (!connectorName) {
          return;
        }
        selectedNodes = $scope.chartViewModel.getSelectedNodes();
        i = 0;
        while (i < selectedNodes.length) {
          node = selectedNodes[i];
          node.addInputConnector({
            name: connectorName
          });
          ++i;
        }
      };
      $scope.addNewOutputConnector = function() {
        var connectorName, i, node, selectedNodes;
        connectorName = prompt("Enter a connector name:", "New connector");
        if (!connectorName) {
          return;
        }
        selectedNodes = $scope.chartViewModel.getSelectedNodes();
        i = 0;
        while (i < selectedNodes.length) {
          node = selectedNodes[i];
          node.addOutputConnector({
            name: connectorName
          });
          ++i;
        }
      };
      $scope.deleteSelected = function() {
        $scope.chartViewModel.deleteSelected();
      };
      return $scope.chartViewModel = new flowchartModel.ChartViewModel(chartDataModel);
    }
  ]);

  removeClassSVG = function(obj, remove) {
    var classes, index;
    classes = obj.attr("class");
    if (!classes) {
      return false;
    }
    index = classes.search(remove);
    if (index === -1) {
      return false;
    } else {
      classes = classes.substring(0, index) + classes.substring(index + remove.length, classes.length);
      obj.attr("class", classes);
      return true;
    }
  };

  hasClassSVG = function(obj, has) {
    var classes, index;
    classes = obj.attr("class");
    if (!classes) {
      return false;
    }
    index = classes.search(has);
    if (index === -1) {
      return false;
    } else {
      return true;
    }
  };

  angular.module("flowChart", ["dragging"]).directive("flowChart", function() {
    return {
      restrict: "E",
      templateUrl: "flowchart/flowchart_template.html",
      replace: true,
      scope: {
        chart: "=chart"
      },
      controller: "FlowChartController"
    };
  }).directive("chartJsonEdit", function() {
    return {
      restrict: "A",
      scope: {
        viewModel: "="
      },
      link: function(scope, elem, attr) {
        var updateJson;
        updateJson = function() {
          var json;
          if (scope.viewModel) {
            json = JSON.stringify(scope.viewModel.data, null, 4);
            $(elem).val(json);
          }
        };
        updateJson();
        scope.$watch("viewModel.data", updateJson, true);
        $(elem).bind("input propertychange", function() {
          var dataModel, json;
          json = $(elem).val();
          dataModel = JSON.parse(json);
          scope.viewModel = flowchart.ChartViewModel(dataModel);
          scope.$digest();
        });
      }
    };
  }).controller("FlowChartController", [
    "$scope", "dragging", "$element", "flowchartModel", FlowChartController = function($scope, dragging, $element, flowchartModel) {
      var controller;
      controller = this;
      this.document = document;
      this.jQuery = function(element) {
        return $(element);
      };
      $scope.draggingConnection = false;
      $scope.connectorSize = 10;
      $scope.dragSelecting = false;
      $scope.mouseOverConnector = null;
      $scope.mouseOverConnection = null;
      $scope.mouseOverNode = null;
      this.connectionClass = "connection";
      this.connectorClass = "connector";
      this.nodeClass = "node";
      this.searchUp = function(element, parentClass) {
        if ((element == null) || element.length === 0) {
          return null;
        }
        if (hasClassSVG(element, parentClass)) {
          return element;
        }
        return this.searchUp(element.parent(), parentClass);
      };
      this.hitTest = function(clientX, clientY) {
        return this.document.elementFromPoint(clientX, clientY);
      };
      this.checkForHit = function(mouseOverElement, whichClass) {
        var hoverElement;
        hoverElement = this.searchUp(this.jQuery(mouseOverElement), whichClass);
        if (!hoverElement) {
          return null;
        }
        return hoverElement.scope();
      };
      this.translateCoordinates = function(x, y) {
        var matrix, point, svg_elem;
        svg_elem = $element.get(0);
        matrix = svg_elem.getScreenCTM();
        point = svg_elem.createSVGPoint();
        point.x = x;
        point.y = y;
        return point.matrixTransform(matrix.inverse());
      };
      $scope.mouseDown = function(evt) {
        $scope.chart.deselectAll();
        dragging.startDrag(evt, {
          dragStarted: function(x, y) {
            var startPoint;
            $scope.dragSelecting = true;
            startPoint = controller.translateCoordinates(x, y);
            $scope.dragSelectionStartPoint = startPoint;
            $scope.dragSelectionRect = {
              x: startPoint.x,
              y: startPoint.y,
              width: 0,
              height: 0
            };
          },
          dragging: function(x, y) {
            var curPoint, startPoint;
            startPoint = $scope.dragSelectionStartPoint;
            curPoint = controller.translateCoordinates(x, y);
            $scope.dragSelectionRect = {
              x: (curPoint.x > startPoint.x ? startPoint.x : curPoint.x),
              y: (curPoint.y > startPoint.y ? startPoint.y : curPoint.y),
              width: (curPoint.x > startPoint.x ? curPoint.x - startPoint.x : startPoint.x - curPoint.x),
              height: (curPoint.y > startPoint.y ? curPoint.y - startPoint.y : startPoint.y - curPoint.y)
            };
          },
          dragEnded: function() {
            $scope.dragSelecting = false;
            $scope.chart.applySelectionRect($scope.dragSelectionRect);
            delete $scope.dragSelectionStartPoint;
            delete $scope.dragSelectionRect;
          }
        });
      };
      $scope.mouseMove = function(evt) {
        var mouseOverElement, scope;
        $scope.mouseOverConnection = null;
        $scope.mouseOverConnector = null;
        $scope.mouseOverNode = null;
        mouseOverElement = controller.hitTest(evt.clientX, evt.clientY);
        if (mouseOverElement == null) {
          return;
        }
        if (!$scope.draggingConnection) {
          scope = controller.checkForHit(mouseOverElement, controller.connectionClass);
          $scope.mouseOverConnection = (scope && scope.connection ? scope.connection : null);
          if ($scope.mouseOverConnection) {
            return;
          }
        }
        scope = controller.checkForHit(mouseOverElement, controller.connectorClass);
        $scope.mouseOverConnector = (scope && scope.connector ? scope.connector : null);
        if ($scope.mouseOverConnector) {
          return;
        }
        scope = controller.checkForHit(mouseOverElement, controller.nodeClass);
        $scope.mouseOverNode = (scope && scope.node ? scope.node : null);
      };
      $scope.nodeMouseDown = function(evt, node) {
        var chart, lastMouseCoords;
        chart = $scope.chart;
        lastMouseCoords = void 0;
        dragging.startDrag(evt, {
          dragStarted: function(x, y) {
            lastMouseCoords = controller.translateCoordinates(x, y);
            if (!node.selected()) {
              chart.deselectAll();
              node.select();
            }
          },
          dragging: function(x, y) {
            var curCoords, deltaX, deltaY;
            curCoords = controller.translateCoordinates(x, y);
            deltaX = curCoords.x - lastMouseCoords.x;
            deltaY = curCoords.y - lastMouseCoords.y;
            chart.updateSelectedNodesLocation(deltaX, deltaY);
            lastMouseCoords = curCoords;
          },
          clicked: function() {
            chart.handleNodeClicked(node, evt.ctrlKey);
          }
        });
      };
      $scope.connectionMouseDown = function(evt, connection) {
        var chart;
        chart = $scope.chart;
        chart.handleConnectionMouseDown(connection, evt.ctrlKey);
        evt.stopPropagation();
        evt.preventDefault();
      };
      return $scope.connectorMouseDown = function(evt, node, connector, connectorIndex, isInputConnector) {
        dragging.startDrag(evt, {
          dragStarted: function(x, y) {
            var curCoords;
            curCoords = controller.translateCoordinates(x, y);
            $scope.draggingConnection = true;
            $scope.dragPoint1 = flowchartModel.computeConnectorPos(node, connectorIndex, isInputConnector);
            $scope.dragPoint2 = {
              x: curCoords.x,
              y: curCoords.y
            };
            $scope.dragTangent1 = flowchartModel.computeConnectionSourceTangent($scope.dragPoint1, $scope.dragPoint2);
            $scope.dragTangent2 = flowchartModel.computeConnectionDestTangent($scope.dragPoint1, $scope.dragPoint2);
          },
          dragging: function(x, y, evt) {
            var startCoords;
            startCoords = controller.translateCoordinates(x, y);
            $scope.dragPoint1 = flowchartModel.computeConnectorPos(node, connectorIndex, isInputConnector);
            $scope.dragPoint2 = {
              x: startCoords.x,
              y: startCoords.y
            };
            $scope.dragTangent1 = flowchartModel.computeConnectionSourceTangent($scope.dragPoint1, $scope.dragPoint2);
            $scope.dragTangent2 = flowchartModel.computeConnectionDestTangent($scope.dragPoint1, $scope.dragPoint2);
          },
          dragEnded: function() {
            if ($scope.mouseOverConnector && $scope.mouseOverConnector !== connector) {
              $scope.chart.createNewConnection(connector, $scope.mouseOverConnector);
            }
            $scope.draggingConnection = false;
            delete $scope.dragPoint1;
            delete $scope.dragTangent1;
            delete $scope.dragPoint2;
            delete $scope.dragTangent2;
          }
        });
      };
    }
  ]);

}).call(this);

/*
//@ sourceMappingURL=app.map
*/
